---
title: "knitr"
author: Michael Sachs
output: 
  md_document:
    variant: markdown_github
---

Introduction to `knitr` 
===================

> Programs are meant to be read by humans and only incidentally for computers to execute. 
> - Donald Knuth

Motivation
----------------

The cut-and-paste approach to report production is tedious, slow, and error-prone. It can be very harmful to reproducible research and it is inconvenient to reproduce results. 

`knitr` is an `R` package that integrates computing and reporting.  By incorporating code into text documents, the analysis, results and discussion are all in one place. Files can then be processed into a diverse array of document formats, including the important ones for collaborative science: pdfs, Word documents, slide presentations, and web pages. 

This is important for reproducible research because you can create reports, papers, presentations in which every table, figure, and inline result is generated by code that is tied to the document itself. It makes life easier when it comes time to make small updates to an analysis, and more importantly, the code becomes more understandable by virtue of being directly related to the text description. 

### The importance of text

There are many advantages to creating scientific content using simple text documents. For one, they are future-proof. Microsoft and Apple are continually updating their software and document formats. In 5 years I probably won't be able to easily open a Word document that I created today, and likewise, when a new document format comes out (remember when .docx was new?) it takes a while for it to be widely adopted. It is highly unlikely that text documents will become obsolete. I can still open a text file that I created on my old Apple IIe. Secondly, content tracking tools like `git` and github work wonderfully with text files. It is dead-easy to view line-by-line changes in a text file. 

Tools like `knitr`, `rmarkdown`, and pandoc do the hard work of translating your text files into "production" documents, like beautifully typeset pdfs, smooth presentations, and Word documents that your collaborators can't live without. Creating the base in a text file allows you to focus on the content and not obsess over the details like formatting and figure placement. 

How to use `knitr` 
-----------------

The basic idea is that your text documents are interrupted by __chunks__ of code that are identified in a special way. These chunks are evaluated by an `R` process in the order that they appear. `R` objects that are created by chunks remain in the enviroment for subsequent chunks. The code in the chunks is displayed and formatted in the document. The results printed by the code are also incorporated into the document as figures, tables, or other objects. Chunks can stand alone, or be included inline with text. Many options exist to format the code and the results, and the options can be extended in countless ways. 

How exactly to use `knitr` depends on the input document format. First I will desribe how to use it with [**markdown**](http://daringfireball.net/projects/markdown/). 


### `knitr` with markdown

When I say markdown I am referring to the plain text formatting syntax, as opposed to the software. Markdown is a syntax closely related to html. It is semanic, like html, but it is much less verbose. Markdown documents can in fact stand on there own as readable text documents without being rendered. Semantic means that elements of the document are described by what they represent, as opposed to how they should look. Thus, for a title, you indicate that this text is the title, as opposed to this text should be large font and in bold. Here is an example with the result:

![mark1](img/mark1.png)

Importantly, the markdown can stand on its own and continue to be readable even though it's a simple text file. Contrast that with the generated html:

![html1](img/html.png)

Or the equivalent Latex:

![tex](img/tex.png)

Thus markdown has the dual advantages of being readble on it's own, and having associated tools to create other document formats from it. 

### Incorporating code chunks

In markdown, the start of a code chunk is indicated by three backticks and the end of a code chunk is indicated by three backticks. At the start of the chunk, you tell `knitr` what type of code it is, give the chunk a name, and other options: 

```{r setup, include=FALSE}
library(stringr)
library(knitr)
opts_chunk$set(tidy = F)

knit_hooks$set(source = function(x, options){
  if (!is.null(options$verbatim) && options$verbatim){
    opts = gsub(",\\s*verbatim\\s*=\\s*TRUE\\s*", "", options$params.src)
    bef = sprintf('\n\n    ```{r %s}\n', opts, "\n")
    stringr::str_c(
      bef, 
      knitr:::indent_block(paste(x, collapse = '\n'), "    "), 
      "\n    ```\n"
    )
  } else {
    stringr::str_c("\n\n```", tolower(options$engine), "\n", 
      paste(x, collapse = '\n'), "\n```\n\n"
    )
  }
})
```

```{r my-first-chunk, results='asis', verbatim = TRUE} 
## code goes in here
```

Inline code is similar, using single backticks instead. Inline code does not have names or options. For example,  ```r rnorm(10)```. 

Here's an example:

```{r mtcars-example, verbatim = TRUE}
head(mtcars)
lm(mpg ~ hp + wt, data = mtcars)
```



